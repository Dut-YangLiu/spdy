
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nileshjagnik/spdy/client_conn.go</option>
				
				<option value="file1">github.com/nileshjagnik/spdy/debug.go</option>
				
				<option value="file2">github.com/nileshjagnik/spdy/frame.go</option>
				
				<option value="file3">github.com/nileshjagnik/spdy/header.go</option>
				
				<option value="file4">github.com/nileshjagnik/spdy/misc.go</option>
				
				<option value="file5">github.com/nileshjagnik/spdy/proxy.go</option>
				
				<option value="file6">github.com/nileshjagnik/spdy/server_conn.go</option>
				
				<option value="file7">github.com/nileshjagnik/spdy/session.go</option>
				
				<option value="file8">github.com/nileshjagnik/spdy/stream.go</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" >// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// client connection related functions

package spdy

import (
        "bytes"
        "net"
        "net/http"
)

func handle(err error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)
        }</span>
}

// NewRecorder returns an initialized ResponseRecorder.
func NewRecorder() *ResponseRecorder <span class="cov0" title="0">{
        return &amp;ResponseRecorder{
                HeaderMap: make(http.Header),
                Body:      new(bytes.Buffer),
                Code:      200,
        }
}</span>

// Header returns the response headers.
func (rw *ResponseRecorder) Header() http.Header <span class="cov0" title="0">{
        m := rw.HeaderMap
        if m == nil </span><span class="cov0" title="0">{
                m = make(http.Header)
                rw.HeaderMap = m
        }</span>
        <span class="cov0" title="0">return m</span>
}

// Write always succeeds and writes to rw.Body.
func (rw *ResponseRecorder) Write(buf []byte) (int, error) <span class="cov0" title="0">{
        if !rw.wroteHeader </span><span class="cov0" title="0">{
                rw.WriteHeader(200)
        }</span>
        <span class="cov0" title="0">if rw.Body != nil </span><span class="cov0" title="0">{
                len, err := rw.Body.Write(buf)
                return len, err
        }</span> <span class="cov0" title="0">else {
                rw.Body = new(bytes.Buffer)
                len, err := rw.Body.Write(buf)
                return len, err
        }</span>
        <span class="cov0" title="0">return len(buf), nil</span>
}

// WriteHeader sets rw.Code.
func (rw *ResponseRecorder) WriteHeader(code int) <span class="cov0" title="0">{
        if !rw.wroteHeader </span><span class="cov0" title="0">{
                rw.Code = code
        }</span>
        <span class="cov0" title="0">rw.wroteHeader = true</span>
}

// Flush sets rw.Flushed to true.
func (rw *ResponseRecorder) Flush() <span class="cov0" title="0">{
        if !rw.wroteHeader </span><span class="cov0" title="0">{
                rw.WriteHeader(200)
        }</span>
        <span class="cov0" title="0">rw.Flushed = true</span>
}

func NewClient(addr string) (*Client, error) <span class="cov0" title="0">{
        conn, err := net.Dial("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;Client{}, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{cn: conn}, nil</span>
}

//to get a response from the client
func (c *Client) Do(req *http.Request) (*http.Response, error) <span class="cov0" title="0">{
        session := NewClientSession(c.cn)
        go session.Serve()
        c.rr = new(ResponseRecorder)
        err := session.NewStreamProxy(req, c.rr)
        if err != nil </span><span class="cov0" title="0">{
                return &amp;http.Response{}, err
        }</span>
        <span class="cov0" title="0">resp := &amp;http.Response{
                StatusCode:    c.rr.Code,
                Proto:         "HTTP/1.1",
                ProtoMajor:    1,
                ProtoMinor:    1,
                Body:          &amp;readCloser{c.rr.Body},
                ContentLength: int64(c.rr.Body.Len()),
        }
        return resp, nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// Debug and logging related functions

package spdy

import (
        "io"
        "io/ioutil"
        logging "log"
        "os"
)

// regular app logging - enabled by default
var log = logging.New(os.Stderr, "[SPDY] ", logging.LstdFlags|logging.Lshortfile)

// app logging for the purposes of debugging - disabled by default
var debug = logging.New(ioutil.Discard, "[SPDY DEBUG] ", logging.LstdFlags)

// EnableDebug turns on the output of debugging messages to Stdout
func EnableDebug() <span class="cov0" title="0">{
        debug = logging.New(os.Stdout, "[SPDY DEBUG] ", logging.LstdFlags)
}</span>

// SetLog sets the output of logging to a given io.Writer
func SetLog(w io.Writer) <span class="cov0" title="0">{
        log = logging.New(w, "[SPDY] ", logging.LstdFlags|logging.Lshortfile)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// Frame related functions for generic for control/data frames
// as well as specific frame related functions

package spdy

import (
        "bytes"
        "encoding/binary"
        "fmt"
        "io"
        "strings"
)

// ========================================
// Control Frames
// ========================================
func (f controlFrame) Flags() frameFlags <span class="cov0" title="0">{ return f.flags }</span>
func (f controlFrame) Data() []byte      <span class="cov0" title="0">{ return f.data }</span>

func (f controlFrame) String() string <span class="cov8" title="1">{
        s := fmt.Sprintf("Control frame %s, flags: %s, size: %d\n", f.kind, f.flags, len(f.data))
        return s
}</span>

func (f controlFrame) isFIN() bool <span class="cov8" title="1">{ return f.flags&amp;FLAG_FIN == FLAG_FIN }</span>

func (f frameFlags) String() string <span class="cov8" title="1">{
        if f == FLAG_NONE </span><span class="cov8" title="1">{
                return "-"
        }</span>
        <span class="cov8" title="1">if f == FLAG_FIN </span><span class="cov8" title="1">{
                return "FIN"
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("0x%02x", int(f))</span>
}

func (f controlFrameKind) String() string <span class="cov8" title="1">{
        switch f </span>{
        <span class="cov8" title="1">case FRAME_SYN_STREAM:
                return "SYN_STREAM"</span>
        <span class="cov8" title="1">case FRAME_SYN_REPLY:
                return "SYN_REPLY"</span>
        <span class="cov0" title="0">case FRAME_RST_STREAM:
                return "RST_STREAM"</span>
        <span class="cov0" title="0">case FRAME_SETTINGS:
                return "SETTINGS"</span>
        <span class="cov0" title="0">case FRAME_PING:
                return "PING"</span>
        <span class="cov0" title="0">case FRAME_GOAWAY:
                return "GOAWAY"</span>
        <span class="cov0" title="0">case FRAME_HEADERS:
                return "HEADERS"</span>
        <span class="cov8" title="1">case FRAME_WINDOW_UPDATE:
                return "WINDOW_UPDATE"</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("Type(%#04x)", uint16(f))</span>
}

func (f controlFrame) Write(w io.Writer) (n int64, err error) <span class="cov8" title="1">{

        total := len(f.data) + 8
        debug.Printf("Writing control frame %s, flags: %s, payload: %d", f.kind, f.flags, len(f.data))
        nn, err := writeFrame(w, []interface{}{uint16(0x8000) | uint16(0x0003), f.kind, f.flags}, f.data)
        if nn != total </span><span class="cov0" title="0">{
                log.Println("WARNING in controlFrame.Write, wrote", nn, "vs. frame size", total)
        }</span>
        <span class="cov8" title="1">return int64(nn), err</span>
}

// read the stream ID from the payload
// applies to SYN_STREAM, SYN_REPLY, RST_STREAM, GOAWAY, HEADERS and WINDOWS_UPDATE
func (f *controlFrame) streamID() (id streamID) <span class="cov8" title="1">{
        data := bytes.NewBuffer(f.data[0:4])
        err := binary.Read(data, binary.BigEndian, &amp;id)
        if err != nil </span><span class="cov0" title="0">{
                log.Println("ERROR: Cannot read stream ID from a control frame that is supposed to have a stream ID:", err)
                id = 0
                return
        }</span>
        <span class="cov8" title="1">id &amp;= 0x7fffffff

        return</span>
}

// ========================================
// Data Frames
// ========================================
func (f dataFrame) Flags() frameFlags <span class="cov0" title="0">{ return f.flags }</span>
func (f dataFrame) Data() []byte      <span class="cov0" title="0">{ return f.data }</span>
func (f dataFrame) isFIN() bool       <span class="cov8" title="1">{ return f.flags&amp;FLAG_FIN == FLAG_FIN }</span>

func (f dataFrame) Write(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        total := len(f.data) + 8
        debug.Printf("Writing data frame, flags: %s, size: %d", f.flags, len(f.data))
        nn, err := writeFrame(w, []interface{}{f.stream &amp; 0x7fffffff, f.flags}, f.data)
        if nn != total </span><span class="cov0" title="0">{
                log.Println("WARNING in dataFrame.Write, wrote", nn, "vs. frame size", total)
        }</span>
        <span class="cov8" title="1">return int64(nn), err</span>
}

func (f dataFrame) String() string <span class="cov8" title="1">{
        l := len(f.data)
        s := fmt.Sprintf("\n\tFrame: DATA of size %d, for stream #%d", l, f.stream)
        s += fmt.Sprintf(", Flags: %s", f.flags)
        if l &gt; 16 </span><span class="cov8" title="1">{
                s += fmt.Sprintf("\n\tData: [%x .. %x]", f.data[0:6], f.data[l-6:])
        }</span> <span class="cov8" title="1">else if l &gt; 0 </span><span class="cov8" title="1">{
                s += fmt.Sprintf("\n\tData: [%x]", f.data)
        }</span>
        <span class="cov8" title="1">return s</span>
}

// ========================================
// Generic frame-writing utilities
// ========================================

func writeFrame(w io.Writer, head []interface{}, data []byte) (n int, err error) <span class="cov8" title="1">{
        var nn int
        // Header (40 bits)
        err = writeBinary(w, head...)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">n += 5 // frame head, in bytes, without the length field

        // Length (24 bits)
        length := len(data)
        nn, err = w.Write([]byte{
                byte(length &amp; 0x00ff0000 &gt;&gt; 16),
                byte(length &amp; 0x0000ff00 &gt;&gt; 8),
                byte(length &amp; 0x000000ff),
        })
        n += nn
        if err != nil </span><span class="cov0" title="0">{
                log.Println("Write of length failed:", err)
                return
        }</span>
        // Data
        <span class="cov8" title="1">if length &gt; 0 </span><span class="cov8" title="1">{
                nn, err = w.Write(data)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("Write of data failed:", err)
                        return
                }</span>
                <span class="cov8" title="1">n += nn</span>
        }
        <span class="cov8" title="1">return</span>
}

func writeBinary(r io.Writer, args ...interface{}) (err error) <span class="cov8" title="1">{
        for _, a := range args </span><span class="cov8" title="1">{
                err = binary.Write(r, binary.BigEndian, a)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// ========================================
// Generic frame-reading utilities
// ========================================

// readFrame reads an entire frame into memory
func readFrame(r io.Reader) (f frame, err error) <span class="cov8" title="1">{
        headBuffer := new(bytes.Buffer)
        _, err = io.CopyN(headBuffer, r, 5)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">if headBuffer.Bytes()[0]&amp;0x80 == 0 </span><span class="cov8" title="1">{
                // Data
                df := dataFrame{}
                err = readBinary(headBuffer, &amp;df.stream, &amp;df.flags)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">df.data, err = readData(r)
                f = df</span>
        } <span class="cov8" title="1">else {
                // Control
                cf := controlFrame{}
                headBuffer.ReadByte() // FIXME skip version word
                headBuffer.ReadByte()
                err = readBinary(headBuffer, &amp;cf.kind, &amp;cf.flags)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">cf.data, err = readData(r)
                f = cf</span>
        }
        <span class="cov8" title="1">return</span>
}

func readBinary(r io.Reader, args ...interface{}) (err error) <span class="cov8" title="1">{
        for _, a := range args </span><span class="cov8" title="1">{
                err = binary.Read(r, binary.BigEndian, a)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func readData(r io.Reader) (data []byte, err error) <span class="cov8" title="1">{
        lengthField := make([]byte, 3)
        _, err = io.ReadFull(r, lengthField)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">var length uint32
        length |= uint32(lengthField[0]) &lt;&lt; 16
        length |= uint32(lengthField[1]) &lt;&lt; 8
        length |= uint32(lengthField[2])

        if length &gt; 0 </span><span class="cov8" title="1">{
                data = make([]byte, int(length))
                _, err = io.ReadFull(r, data)
                if err != nil </span><span class="cov0" title="0">{
                        data = nil
                        return
                }</span>
        } <span class="cov8" title="1">else {
                data = []byte{}
        }</span>
        <span class="cov8" title="1">return</span>
}

// ========================================
// SYN_STREAM frame
// ========================================

func (frame frameSynStream) Flags() frameFlags <span class="cov0" title="0">{
        return frame.flags
}</span>

func (frame frameSynStream) Data() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        // stream-id
        binary.Write(buf, binary.BigEndian, frame.stream&amp;0x7fffffff)
        // associated-to-stream-id FIXME in the long term
        binary.Write(buf, binary.BigEndian, frame.associated_stream&amp;0x7fffffff)
        // Priority &amp; unused/reserved
        var misc uint16 = uint16((frame.priority &amp; 0x7) &lt;&lt; 13)
        binary.Write(buf, binary.BigEndian, misc)
        // debug.Println("Before header:", buf.Bytes())
        frame.session.headerWriter.writeHeader(buf, frame.header)
        // debug.Println("Compressed header:", buf.Bytes())
        return buf.Bytes()
}</span>

func (frame frameSynStream) Write(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        f := controlFrame{kind: FRAME_SYN_STREAM, flags: frame.flags, data: frame.Data()}
        return f.Write(w)
}</span>

// print details of the frame to a string
func (frame frameSynStream) String() string <span class="cov8" title="1">{
        s := fmt.Sprintf("\n\tFrame: SYN_STREAM, Stream #%d", frame.stream)
        s += fmt.Sprintf(", Flags: %s", frame.flags)
        s += fmt.Sprintf("\n\tHeaders:\n")
        for i := range frame.header </span><span class="cov8" title="1">{
                s += fmt.Sprintf("\t\t%s: %s\n", i, strings.Join(frame.header[i], ", "))
        }</span>
        <span class="cov8" title="1">return s</span>
}

// ========================================
// SYN_REPLY frame
// ========================================

func (frame frameSynReply) Flags() frameFlags <span class="cov0" title="0">{
        return frame.flags
}</span>

func (frame frameSynReply) Data() []byte <span class="cov8" title="1">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, frame.stream&amp;0x7fffffff)
        frame.session.headerWriter.writeHeader(buf, frame.headers)
        return buf.Bytes()
}</span>

func (frame frameSynReply) Write(w io.Writer) (n int64, err error) <span class="cov8" title="1">{
        cf := controlFrame{kind: FRAME_SYN_REPLY, data: frame.Data()}
        return cf.Write(w)
}</span>

// print details of the frame to a string
func (frame frameSynReply) String() string <span class="cov8" title="1">{
        s := fmt.Sprintf("\n\tFrame: SYN_REPLY, Stream #%d", frame.stream)
        s += fmt.Sprintf(", Flags: %s", frame.flags)
        s += fmt.Sprintf("\n\tHeaders:\n")
        for i := range frame.headers </span><span class="cov8" title="1">{
                s += fmt.Sprintf("\t\t%s: %s\n", i, strings.Join(frame.headers[i], ", "))
        }</span>
        <span class="cov8" title="1">return s</span>
}

// ========================================
// SETTINGS frame
// ========================================

func (s settings) Flags() frameFlags <span class="cov0" title="0">{
        return s.flags
}</span>

func (s settings) Data() []byte <span class="cov0" title="0">{
        buf := new(bytes.Buffer)
        binary.Write(buf, binary.BigEndian, s.count)
        for i := range s.svp </span><span class="cov0" title="0">{
                binary.Write(buf, binary.BigEndian, s.svp[i].flags)
                binary.Write(buf, binary.BigEndian, s.svp[i].id)
                binary.Write(buf, binary.BigEndian, s.svp[i].value)
        }</span>
        <span class="cov0" title="0">return buf.Bytes()</span>
}

func (s settings) Write(w io.Writer) (n int64, err error) <span class="cov0" title="0">{
        cf := controlFrame{kind: FRAME_SETTINGS, flags: s.flags, data: s.Data()}
        return cf.Write(w)
}</span>

func (s settings) String() (r string) <span class="cov0" title="0">{
        r = fmt.Sprintf("\n\tFrame: SETTINGS, Flags: %s\n", s.flags)
        r += fmt.Sprintf("\tValue/Pairs (%d):\n", s.count)
        for i := range s.svp </span><span class="cov0" title="0">{
                r += fmt.Sprintf("\t\t%d: %d\tflags: %d\n", s.svp[i].id, s.svp[i].value, s.svp[i].flags)
        }</span>
        <span class="cov0" title="0">return</span>
}

// ========================================
// WINDOW_UPDATE frame
// ========================================

// takes a frame and the delta window size and returns a WINDOW_UPDATE frame
func windowUpdateFor(id streamID, dws int) frame <span class="cov8" title="1">{

        data := new(bytes.Buffer)
        binary.Write(data, binary.BigEndian, id)
        binary.Write(data, binary.BigEndian, uint32(dws))

        return controlFrame{kind: FRAME_WINDOW_UPDATE, data: data.Bytes()}
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// This file contains header-handling functions
// The header dictionary came from the SPDY standard.
// Some of the functions came from Jamie Hall's
// SPDY go library.

package spdy

import (
        "bytes"
        "compress/zlib"
        "encoding/binary"
        "io"
        "net/http"
        "strings"
        "sync"
)

type hrSource struct {
        r io.Reader
        m sync.RWMutex
        c *sync.Cond
}

func (src *hrSource) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        src.m.RLock()
        for src.r == nil </span><span class="cov0" title="0">{
                src.c.Wait()
        }</span>
        <span class="cov8" title="1">n, err = src.r.Read(p)
        src.m.RUnlock()
        if err == io.EOF </span><span class="cov0" title="0">{
                src.change(nil)
                err = nil
        }</span>
        <span class="cov8" title="1">return</span>
}

func (src *hrSource) change(r io.Reader) <span class="cov8" title="1">{
        src.m.Lock()
        defer src.m.Unlock()
        src.r = r
        src.c.Broadcast()
}</span>

// A headerReader reads zlib-compressed headers from discontiguous sources.
type headerReader struct {
        source       hrSource
        decompressor io.ReadCloser
}

// newHeaderReader creates a headerReader with the initial dictionary.
func newHeaderReader() (hr *headerReader) <span class="cov8" title="1">{
        hr = new(headerReader)
        hr.source.c = sync.NewCond(hr.source.m.RLocker())
        return
}</span>

// ReadHeader reads a set of headers from a reader.
func (hr *headerReader) readHeader(r io.Reader) (h http.Header, err error) <span class="cov0" title="0">{
        hr.source.change(r)
        h, err = hr.read()
        return
}</span>

// Decode reads a set of headers from a block of bytes.
func (hr *headerReader) decode(data []byte) (h http.Header, err error) <span class="cov8" title="1">{
        hr.source.change(bytes.NewBuffer(data))
        h, err = hr.read()
        return
}</span>

func (hr *headerReader) read() (h http.Header, err error) <span class="cov8" title="1">{
        var count uint32
        if hr.decompressor == nil </span><span class="cov8" title="1">{
                hr.decompressor, err = zlib.NewReaderDict(&amp;hr.source, headerDictionary)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov8" title="1">err = binary.Read(hr.decompressor, binary.BigEndian, &amp;count)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">h = make(http.Header, int(count))
        for i := 0; i &lt; int(count); i++ </span><span class="cov8" title="1">{
                var name, value string
                name, err = readHeaderString(hr.decompressor)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">value, err = readHeaderString(hr.decompressor)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">valueList := strings.Split(string(value), "\x00")
                for _, v := range valueList </span><span class="cov8" title="1">{
                        h.Add(name, v)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

func readHeaderString(r io.Reader) (s string, err error) <span class="cov8" title="1">{
        var length uint32
        err = binary.Read(r, binary.BigEndian, &amp;length)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">data := make([]byte, int(length))
        _, err = io.ReadFull(r, data)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return string(data), nil</span>
}

// write zlib-compressed headers on different streams
type headerWriter struct {
        compressor *zlib.Writer
        buffer     *bytes.Buffer
}

// creates a headerWriter ready to compress headers
func newHeaderWriter() (hw *headerWriter) <span class="cov8" title="1">{
        hw = &amp;headerWriter{buffer: new(bytes.Buffer)}
        hw.compressor, _ = zlib.NewWriterLevelDict(hw.buffer, zlib.BestCompression, headerDictionary)
        return
}</span>

// write a header block directly to a writer
func (hw *headerWriter) writeHeader(w io.Writer, h http.Header) (err error) <span class="cov8" title="1">{
        hw.write(h)
        _, err = io.Copy(w, hw.buffer)
        hw.buffer.Reset()
        return
}</span>

// Encode returns a compressed header block.
func (hw *headerWriter) encode(h http.Header) (data []byte) <span class="cov0" title="0">{
        hw.write(h)
        data = make([]byte, hw.buffer.Len())
        hw.buffer.Read(data)
        return
}</span>

func (hw *headerWriter) write(h http.Header) <span class="cov8" title="1">{
        binary.Write(hw.compressor, binary.BigEndian, uint32(len(h)))
        for k, vals := range h </span><span class="cov8" title="1">{
                k = strings.ToLower(k)
                binary.Write(hw.compressor, binary.BigEndian, uint32(len(k)))
                binary.Write(hw.compressor, binary.BigEndian, []byte(k))
                v := strings.Join(vals, "\x00")
                binary.Write(hw.compressor, binary.BigEndian, uint32(len(v)))
                binary.Write(hw.compressor, binary.BigEndian, []byte(v))
        }</span>
        <span class="cov8" title="1">hw.compressor.Flush()</span>
}

// compression header for SPDY/3
var headerDictionary = []byte{
        0x00, 0x00, 0x00, 0x07, 0x6f, 0x70, 0x74, 0x69,
        0x6f, 0x6e, 0x73, 0x00, 0x00, 0x00, 0x04, 0x68,
        0x65, 0x61, 0x64, 0x00, 0x00, 0x00, 0x04, 0x70,
        0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x03, 0x70,
        0x75, 0x74, 0x00, 0x00, 0x00, 0x06, 0x64, 0x65,
        0x6c, 0x65, 0x74, 0x65, 0x00, 0x00, 0x00, 0x05,
        0x74, 0x72, 0x61, 0x63, 0x65, 0x00, 0x00, 0x00,
        0x06, 0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x00,
        0x00, 0x00, 0x0e, 0x61, 0x63, 0x63, 0x65, 0x70,
        0x74, 0x2d, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,
        0x74, 0x00, 0x00, 0x00, 0x0f, 0x61, 0x63, 0x63,
        0x65, 0x70, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,
        0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x0f,
        0x61, 0x63, 0x63, 0x65, 0x70, 0x74, 0x2d, 0x6c,
        0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65, 0x00,
        0x00, 0x00, 0x0d, 0x61, 0x63, 0x63, 0x65, 0x70,
        0x74, 0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x73,
        0x00, 0x00, 0x00, 0x03, 0x61, 0x67, 0x65, 0x00,
        0x00, 0x00, 0x05, 0x61, 0x6c, 0x6c, 0x6f, 0x77,
        0x00, 0x00, 0x00, 0x0d, 0x61, 0x75, 0x74, 0x68,
        0x6f, 0x72, 0x69, 0x7a, 0x61, 0x74, 0x69, 0x6f,
        0x6e, 0x00, 0x00, 0x00, 0x0d, 0x63, 0x61, 0x63,
        0x68, 0x65, 0x2d, 0x63, 0x6f, 0x6e, 0x74, 0x72,
        0x6f, 0x6c, 0x00, 0x00, 0x00, 0x0a, 0x63, 0x6f,
        0x6e, 0x6e, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e,
        0x00, 0x00, 0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74,
        0x65, 0x6e, 0x74, 0x2d, 0x62, 0x61, 0x73, 0x65,
        0x00, 0x00, 0x00, 0x10, 0x63, 0x6f, 0x6e, 0x74,
        0x65, 0x6e, 0x74, 0x2d, 0x65, 0x6e, 0x63, 0x6f,
        0x64, 0x69, 0x6e, 0x67, 0x00, 0x00, 0x00, 0x10,
        0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d,
        0x6c, 0x61, 0x6e, 0x67, 0x75, 0x61, 0x67, 0x65,
        0x00, 0x00, 0x00, 0x0e, 0x63, 0x6f, 0x6e, 0x74,
        0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x65, 0x6e, 0x67,
        0x74, 0x68, 0x00, 0x00, 0x00, 0x10, 0x63, 0x6f,
        0x6e, 0x74, 0x65, 0x6e, 0x74, 0x2d, 0x6c, 0x6f,
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00,
        0x00, 0x0b, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x2d, 0x6d, 0x64, 0x35, 0x00, 0x00, 0x00,
        0x0d, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e, 0x74,
        0x2d, 0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00,
        0x00, 0x0c, 0x63, 0x6f, 0x6e, 0x74, 0x65, 0x6e,
        0x74, 0x2d, 0x74, 0x79, 0x70, 0x65, 0x00, 0x00,
        0x00, 0x04, 0x64, 0x61, 0x74, 0x65, 0x00, 0x00,
        0x00, 0x04, 0x65, 0x74, 0x61, 0x67, 0x00, 0x00,
        0x00, 0x06, 0x65, 0x78, 0x70, 0x65, 0x63, 0x74,
        0x00, 0x00, 0x00, 0x07, 0x65, 0x78, 0x70, 0x69,
        0x72, 0x65, 0x73, 0x00, 0x00, 0x00, 0x04, 0x66,
        0x72, 0x6f, 0x6d, 0x00, 0x00, 0x00, 0x04, 0x68,
        0x6f, 0x73, 0x74, 0x00, 0x00, 0x00, 0x08, 0x69,
        0x66, 0x2d, 0x6d, 0x61, 0x74, 0x63, 0x68, 0x00,
        0x00, 0x00, 0x11, 0x69, 0x66, 0x2d, 0x6d, 0x6f,
        0x64, 0x69, 0x66, 0x69, 0x65, 0x64, 0x2d, 0x73,
        0x69, 0x6e, 0x63, 0x65, 0x00, 0x00, 0x00, 0x0d,
        0x69, 0x66, 0x2d, 0x6e, 0x6f, 0x6e, 0x65, 0x2d,
        0x6d, 0x61, 0x74, 0x63, 0x68, 0x00, 0x00, 0x00,
        0x08, 0x69, 0x66, 0x2d, 0x72, 0x61, 0x6e, 0x67,
        0x65, 0x00, 0x00, 0x00, 0x13, 0x69, 0x66, 0x2d,
        0x75, 0x6e, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69,
        0x65, 0x64, 0x2d, 0x73, 0x69, 0x6e, 0x63, 0x65,
        0x00, 0x00, 0x00, 0x0d, 0x6c, 0x61, 0x73, 0x74,
        0x2d, 0x6d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65,
        0x64, 0x00, 0x00, 0x00, 0x08, 0x6c, 0x6f, 0x63,
        0x61, 0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00,
        0x0c, 0x6d, 0x61, 0x78, 0x2d, 0x66, 0x6f, 0x72,
        0x77, 0x61, 0x72, 0x64, 0x73, 0x00, 0x00, 0x00,
        0x06, 0x70, 0x72, 0x61, 0x67, 0x6d, 0x61, 0x00,
        0x00, 0x00, 0x12, 0x70, 0x72, 0x6f, 0x78, 0x79,
        0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e, 0x74,
        0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00, 0x00,
        0x13, 0x70, 0x72, 0x6f, 0x78, 0x79, 0x2d, 0x61,
        0x75, 0x74, 0x68, 0x6f, 0x72, 0x69, 0x7a, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x05,
        0x72, 0x61, 0x6e, 0x67, 0x65, 0x00, 0x00, 0x00,
        0x07, 0x72, 0x65, 0x66, 0x65, 0x72, 0x65, 0x72,
        0x00, 0x00, 0x00, 0x0b, 0x72, 0x65, 0x74, 0x72,
        0x79, 0x2d, 0x61, 0x66, 0x74, 0x65, 0x72, 0x00,
        0x00, 0x00, 0x06, 0x73, 0x65, 0x72, 0x76, 0x65,
        0x72, 0x00, 0x00, 0x00, 0x02, 0x74, 0x65, 0x00,
        0x00, 0x00, 0x07, 0x74, 0x72, 0x61, 0x69, 0x6c,
        0x65, 0x72, 0x00, 0x00, 0x00, 0x11, 0x74, 0x72,
        0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x2d, 0x65,
        0x6e, 0x63, 0x6f, 0x64, 0x69, 0x6e, 0x67, 0x00,
        0x00, 0x00, 0x07, 0x75, 0x70, 0x67, 0x72, 0x61,
        0x64, 0x65, 0x00, 0x00, 0x00, 0x0a, 0x75, 0x73,
        0x65, 0x72, 0x2d, 0x61, 0x67, 0x65, 0x6e, 0x74,
        0x00, 0x00, 0x00, 0x04, 0x76, 0x61, 0x72, 0x79,
        0x00, 0x00, 0x00, 0x03, 0x76, 0x69, 0x61, 0x00,
        0x00, 0x00, 0x07, 0x77, 0x61, 0x72, 0x6e, 0x69,
        0x6e, 0x67, 0x00, 0x00, 0x00, 0x10, 0x77, 0x77,
        0x77, 0x2d, 0x61, 0x75, 0x74, 0x68, 0x65, 0x6e,
        0x74, 0x69, 0x63, 0x61, 0x74, 0x65, 0x00, 0x00,
        0x00, 0x06, 0x6d, 0x65, 0x74, 0x68, 0x6f, 0x64,
        0x00, 0x00, 0x00, 0x03, 0x67, 0x65, 0x74, 0x00,
        0x00, 0x00, 0x06, 0x73, 0x74, 0x61, 0x74, 0x75,
        0x73, 0x00, 0x00, 0x00, 0x06, 0x32, 0x30, 0x30,
        0x20, 0x4f, 0x4b, 0x00, 0x00, 0x00, 0x07, 0x76,
        0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00,
        0x00, 0x08, 0x48, 0x54, 0x54, 0x50, 0x2f, 0x31,
        0x2e, 0x31, 0x00, 0x00, 0x00, 0x03, 0x75, 0x72,
        0x6c, 0x00, 0x00, 0x00, 0x06, 0x70, 0x75, 0x62,
        0x6c, 0x69, 0x63, 0x00, 0x00, 0x00, 0x0a, 0x73,
        0x65, 0x74, 0x2d, 0x63, 0x6f, 0x6f, 0x6b, 0x69,
        0x65, 0x00, 0x00, 0x00, 0x0a, 0x6b, 0x65, 0x65,
        0x70, 0x2d, 0x61, 0x6c, 0x69, 0x76, 0x65, 0x00,
        0x00, 0x00, 0x06, 0x6f, 0x72, 0x69, 0x67, 0x69,
        0x6e, 0x31, 0x30, 0x30, 0x31, 0x30, 0x31, 0x32,
        0x30, 0x31, 0x32, 0x30, 0x32, 0x32, 0x30, 0x35,
        0x32, 0x30, 0x36, 0x33, 0x30, 0x30, 0x33, 0x30,
        0x32, 0x33, 0x30, 0x33, 0x33, 0x30, 0x34, 0x33,
        0x30, 0x35, 0x33, 0x30, 0x36, 0x33, 0x30, 0x37,
        0x34, 0x30, 0x32, 0x34, 0x30, 0x35, 0x34, 0x30,
        0x36, 0x34, 0x30, 0x37, 0x34, 0x30, 0x38, 0x34,
        0x30, 0x39, 0x34, 0x31, 0x30, 0x34, 0x31, 0x31,
        0x34, 0x31, 0x32, 0x34, 0x31, 0x33, 0x34, 0x31,
        0x34, 0x34, 0x31, 0x35, 0x34, 0x31, 0x36, 0x34,
        0x31, 0x37, 0x35, 0x30, 0x32, 0x35, 0x30, 0x34,
        0x35, 0x30, 0x35, 0x32, 0x30, 0x33, 0x20, 0x4e,
        0x6f, 0x6e, 0x2d, 0x41, 0x75, 0x74, 0x68, 0x6f,
        0x72, 0x69, 0x74, 0x61, 0x74, 0x69, 0x76, 0x65,
        0x20, 0x49, 0x6e, 0x66, 0x6f, 0x72, 0x6d, 0x61,
        0x74, 0x69, 0x6f, 0x6e, 0x32, 0x30, 0x34, 0x20,
        0x4e, 0x6f, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x65,
        0x6e, 0x74, 0x33, 0x30, 0x31, 0x20, 0x4d, 0x6f,
        0x76, 0x65, 0x64, 0x20, 0x50, 0x65, 0x72, 0x6d,
        0x61, 0x6e, 0x65, 0x6e, 0x74, 0x6c, 0x79, 0x34,
        0x30, 0x30, 0x20, 0x42, 0x61, 0x64, 0x20, 0x52,
        0x65, 0x71, 0x75, 0x65, 0x73, 0x74, 0x34, 0x30,
        0x31, 0x20, 0x55, 0x6e, 0x61, 0x75, 0x74, 0x68,
        0x6f, 0x72, 0x69, 0x7a, 0x65, 0x64, 0x34, 0x30,
        0x33, 0x20, 0x46, 0x6f, 0x72, 0x62, 0x69, 0x64,
        0x64, 0x65, 0x6e, 0x34, 0x30, 0x34, 0x20, 0x4e,
        0x6f, 0x74, 0x20, 0x46, 0x6f, 0x75, 0x6e, 0x64,
        0x35, 0x30, 0x30, 0x20, 0x49, 0x6e, 0x74, 0x65,
        0x72, 0x6e, 0x61, 0x6c, 0x20, 0x53, 0x65, 0x72,
        0x76, 0x65, 0x72, 0x20, 0x45, 0x72, 0x72, 0x6f,
        0x72, 0x35, 0x30, 0x31, 0x20, 0x4e, 0x6f, 0x74,
        0x20, 0x49, 0x6d, 0x70, 0x6c, 0x65, 0x6d, 0x65,
        0x6e, 0x74, 0x65, 0x64, 0x35, 0x30, 0x33, 0x20,
        0x53, 0x65, 0x72, 0x76, 0x69, 0x63, 0x65, 0x20,
        0x55, 0x6e, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61,
        0x62, 0x6c, 0x65, 0x4a, 0x61, 0x6e, 0x20, 0x46,
        0x65, 0x62, 0x20, 0x4d, 0x61, 0x72, 0x20, 0x41,
        0x70, 0x72, 0x20, 0x4d, 0x61, 0x79, 0x20, 0x4a,
        0x75, 0x6e, 0x20, 0x4a, 0x75, 0x6c, 0x20, 0x41,
        0x75, 0x67, 0x20, 0x53, 0x65, 0x70, 0x74, 0x20,
        0x4f, 0x63, 0x74, 0x20, 0x4e, 0x6f, 0x76, 0x20,
        0x44, 0x65, 0x63, 0x20, 0x30, 0x30, 0x3a, 0x30,
        0x30, 0x3a, 0x30, 0x30, 0x20, 0x4d, 0x6f, 0x6e,
        0x2c, 0x20, 0x54, 0x75, 0x65, 0x2c, 0x20, 0x57,
        0x65, 0x64, 0x2c, 0x20, 0x54, 0x68, 0x75, 0x2c,
        0x20, 0x46, 0x72, 0x69, 0x2c, 0x20, 0x53, 0x61,
        0x74, 0x2c, 0x20, 0x53, 0x75, 0x6e, 0x2c, 0x20,
        0x47, 0x4d, 0x54, 0x63, 0x68, 0x75, 0x6e, 0x6b,
        0x65, 0x64, 0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f,
        0x68, 0x74, 0x6d, 0x6c, 0x2c, 0x69, 0x6d, 0x61,
        0x67, 0x65, 0x2f, 0x70, 0x6e, 0x67, 0x2c, 0x69,
        0x6d, 0x61, 0x67, 0x65, 0x2f, 0x6a, 0x70, 0x67,
        0x2c, 0x69, 0x6d, 0x61, 0x67, 0x65, 0x2f, 0x67,
        0x69, 0x66, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78,
        0x6d, 0x6c, 0x2c, 0x61, 0x70, 0x70, 0x6c, 0x69,
        0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x78,
        0x68, 0x74, 0x6d, 0x6c, 0x2b, 0x78, 0x6d, 0x6c,
        0x2c, 0x74, 0x65, 0x78, 0x74, 0x2f, 0x70, 0x6c,
        0x61, 0x69, 0x6e, 0x2c, 0x74, 0x65, 0x78, 0x74,
        0x2f, 0x6a, 0x61, 0x76, 0x61, 0x73, 0x63, 0x72,
        0x69, 0x70, 0x74, 0x2c, 0x70, 0x75, 0x62, 0x6c,
        0x69, 0x63, 0x70, 0x72, 0x69, 0x76, 0x61, 0x74,
        0x65, 0x6d, 0x61, 0x78, 0x2d, 0x61, 0x67, 0x65,
        0x3d, 0x67, 0x7a, 0x69, 0x70, 0x2c, 0x64, 0x65,
        0x66, 0x6c, 0x61, 0x74, 0x65, 0x2c, 0x73, 0x64,
        0x63, 0x68, 0x63, 0x68, 0x61, 0x72, 0x73, 0x65,
        0x74, 0x3d, 0x75, 0x74, 0x66, 0x2d, 0x38, 0x63,
        0x68, 0x61, 0x72, 0x73, 0x65, 0x74, 0x3d, 0x69,
        0x73, 0x6f, 0x2d, 0x38, 0x38, 0x35, 0x39, 0x2d,
        0x31, 0x2c, 0x75, 0x74, 0x66, 0x2d, 0x2c, 0x2a,
        0x2c, 0x65, 0x6e, 0x71, 0x3d, 0x30, 0x2e,
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// Miscellaneous functions

package spdy

import (
        "fmt"
        "net"
        "net/url"
        "syscall"
)

// PriorityFor returns the recommended priority for the given URL
// for best opteration with the library.
func PriorityFor(req *url.URL) uint8 <span class="cov0" title="0">{
        // FIXME: need to implement priorities properly
        return 4
}</span>

// check to see if err is a connection reset
func isConnReset(err error) bool <span class="cov0" title="0">{
        if e, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                if errno, ok := e.Err.(syscall.Errno); ok </span><span class="cov0" title="0">{
                        return errno == syscall.ECONNRESET
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// check to see if err is an network timeout
func isBrokenPipe(err error) bool <span class="cov0" title="0">{
        if e, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                return e.Err == syscall.EPIPE
        }</span>
        <span class="cov0" title="0">return false</span>
}

// return best guess at a string for a network error
func netErrorString(err error) string <span class="cov0" title="0">{
        if e, ok := err.(*net.OpError); ok </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s", e.Err)
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%#v", err)</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// Proxy function

package spdy

import (
        "net/http"
)

// NewStreamProxy starts a new stream and proxies the given HTTP Request to
// it, writing the response to the given ResponseWriter. If there is an error,
// it will be returned, but the ResponseWriter will get a 404 Not Found.
func (s *Session) NewStreamProxy(r *http.Request, w http.ResponseWriter) (err error) <span class="cov8" title="1">{

        str := s.NewClientStream()
        if str == nil </span><span class="cov0" title="0">{
                log.Println("ERROR in NewClientStream: cannot create stream")
                http.NotFound(w, r)
                return
        }</span>
        <span class="cov8" title="1">err = str.Request(r, w)
        if err != nil </span><span class="cov0" title="0">{
                http.NotFound(w, r)
                log.Println("ERROR in Request:", err)
                return
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// server connection related functions

package spdy

import (
        "net"
        "net/http"
        "time"
)

func handleConnection(conn net.Conn, addr string, handler http.Handler) <span class="cov0" title="0">{
        hserve := new(http.Server)
        if handler == nil </span><span class="cov0" title="0">{
                hserve.Handler = http.DefaultServeMux
        }</span> <span class="cov0" title="0">else {
                hserve.Handler = handler
        }</span>
        <span class="cov0" title="0">hserve.Addr = addr
        session := NewServerSession(conn, hserve)
        handle(session.Serve())</span>
}

func ListenAndServe(addr string, handler http.Handler) (err error) <span class="cov0" title="0">{
        ln, err := net.Listen("tcp", addr)
        if err != nil </span><span class="cov0" title="0">{
                // handle error
        }</span>
        <span class="cov0" title="0">var tempDelay time.Duration // how long to sleep on accept failure
        for </span><span class="cov0" title="0">{
                conn, err := ln.Accept()
                if err != nil </span><span class="cov0" title="0">{
                        if ne, ok := err.(net.Error); ok &amp;&amp; ne.Temporary() </span><span class="cov0" title="0">{
                                if tempDelay == 0 </span><span class="cov0" title="0">{
                                        tempDelay = 5 * time.Millisecond
                                }</span> <span class="cov0" title="0">else {
                                        tempDelay *= 2
                                }</span>
                                <span class="cov0" title="0">if max := 1 * time.Second; tempDelay &gt; max </span><span class="cov0" title="0">{
                                        tempDelay = max
                                }</span>
                                <span class="cov0" title="0">log.Printf("http: Accept error: %v; retrying in %v", err, tempDelay)
                                time.Sleep(tempDelay)
                                continue</span>
                        }
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov0" title="0">go handleConnection(conn, addr, handler)</span>
        }
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// Session related functions

package spdy

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "net"
        "net/http"
        "sync/atomic"
        "time"
)

// NewServerSession creates a new Session with the given network connection.
// This Session should be used as a server, and the given http.Server will be
// used to serve requests arriving.  The user should call Serve() once it's
// ready to start serving. New streams will be created as per the SPDY
// protocol.
func NewServerSession(conn net.Conn, server *http.Server) *Session <span class="cov8" title="1">{
        s := &amp;Session{
                conn:         conn,
                out:          make(chan frame),
                in:           make(chan frame),
                new_stream:   make(chan *Stream),
                end_stream:   make(chan *Stream),
                server:       server,
                headerWriter: newHeaderWriter(),
                headerReader: newHeaderReader(),
                nextStream:   2,
                nextPing:     2,
                streams:      make(map[streamID]*Stream),
                pinger:       make(chan uint32),
        }

        return s
}</span>

// NewClientSession creates a new Session that should be used as a client.
// the given http.Server will be used to serve requests arriving.  The user
// should call Serve() once it's ready to start serving. New streams will be
// created as per the SPDY protocol.
func NewClientSession(conn net.Conn) *Session <span class="cov8" title="1">{
        s := &amp;Session{
                conn:         conn,
                out:          make(chan frame),
                in:           make(chan frame),
                new_stream:   make(chan *Stream),
                end_stream:   make(chan *Stream),
                server:       nil,
                headerWriter: newHeaderWriter(),
                headerReader: newHeaderReader(),
                nextStream:   1,
                nextPing:     1,
                streams:      make(map[streamID]*Stream),
                pinger:       make(chan uint32),
        }

        return s
}</span>

// Serve starts serving a Session. This implementation of Serve only returns
// when there has been an error condition.
func (s *Session) Serve() (err error) <span class="cov8" title="1">{

        debug.Println("Session server started")

        receiver_done := make(chan bool)
        sender_done := make(chan bool)

        // start frame sender
        go s.frameSender(sender_done, s.out)

        // start frame receiver
        go s.frameReceiver(receiver_done, s.in)

        // start serving loop
        err = s.session_loop(sender_done, receiver_done)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("ERROR: %s", netErrorString(err))
        }</span>

        // force removing all existing streams
        <span class="cov0" title="0">for i := range s.streams </span><span class="cov0" title="0">{
                str := s.streams[i]
                str.finish_stream()
                delete(s.streams, i)
        }</span>

        // close this session
        <span class="cov0" title="0">s.Close()
        debug.Println("Session closed. Session server done.")

        return</span>
}

func (s *Session) session_loop(sender_done, receiver_done &lt;-chan bool) (err error) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                select </span>{
                <span class="cov8" title="1">case f := &lt;-s.in:
                        // received a frame
                        switch frame := f.(type) </span>{
                        <span class="cov8" title="1">case controlFrame:
                                err = s.processControlFrame(frame)</span>
                        <span class="cov8" title="1">case dataFrame:
                                err = s.processDataFrame(frame)</span>
                        }
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                <span class="cov8" title="1">case ns, ok := &lt;-s.new_stream:
                        // registering a new stream for this session
                        if ok </span><span class="cov8" title="1">{
                                s.streams[ns.id] = ns
                        }</span> <span class="cov0" title="0">else {
                                return
                        }</span>
                <span class="cov8" title="1">case os, ok := &lt;-s.end_stream:
                        // unregistering a stream from this session
                        if ok </span><span class="cov8" title="1">{
                                delete(s.streams, os.id)
                        }</span> <span class="cov0" title="0">else {
                                return
                        }</span>
                <span class="cov0" title="0">case _, _ = &lt;-receiver_done:
                        debug.Println("Session receiver is done")
                        return</span>
                <span class="cov0" title="0">case _, _ = &lt;-sender_done:
                        debug.Println("Session sender is done")
                        return</span>
                }
        }
}

// Close closes the Session and the underlaying network connection.
// It should be called when the Session is idle for best results.
func (s *Session) Close() <span class="cov0" title="0">{
        // FIXME - what else do we need to do here?
        if s.closed </span><span class="cov0" title="0">{
                debug.Println("WARNING: session was already closed - why?")
                return
        }</span>

        <span class="cov0" title="0">s.closed = true

        // in case any of the closes below clashes
        defer no_panics()

        close(s.out)
        close(s.in)
        close(s.pinger)

        debug.Println("Closing the network connection")
        s.conn.Close()</span>
}

// return the next stream id
func (s *Session) nextStreamID() streamID <span class="cov8" title="1">{
        return (streamID)(atomic.AddUint32((*uint32)(&amp;s.nextStream), 2) - 2)
}</span>

// frameSender takes a channel and gets each of the frames coming from
// it and sends them down the session connection, until the channel
// is closed or there are errors in sending over the network
func (s *Session) frameSender(done chan&lt;- bool, in &lt;-chan frame) <span class="cov8" title="1">{
        for f := range in </span><span class="cov8" title="1">{
                s.conn.SetWriteDeadline(time.Now().Add(5 * time.Second))
                _, err := f.Write(s.conn)
                if err != nil </span><span class="cov0" title="0">{
                        log.Println("ERROR in frameSender.Write:", err)
                        break</span>
                }
        }
        <span class="cov0" title="0">done &lt;- true
        debug.Printf("Session sender ended")</span>
}

// frameReceiver takes a channel and receives frames, sending them to
// the network connection until there is an error
func (s *Session) frameReceiver(done chan&lt;- bool, incoming chan&lt;- frame) <span class="cov8" title="1">{
        defer no_panics()

        for </span><span class="cov8" title="1">{
                frame, err := readFrame(s.conn)
                if err == io.EOF </span><span class="cov0" title="0">{
                        // normal reasons, like disconnection, etc.
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        // some other communication error
                        log.Printf("WARN: communication error: %s", netErrorString(err))
                        break</span>
                }
                // ship the frame upstream -- this must be ensured to not block
                <span class="cov8" title="1">debug.Printf("Session got: %s", frame)
                incoming &lt;- frame</span>
        }
        <span class="cov0" title="0">done &lt;- true
        debug.Printf("Session receiver ended")</span>
}

func (s *Session) processControlFrame(frame controlFrame) (err error) <span class="cov8" title="1">{

        switch frame.kind </span>{
        <span class="cov8" title="1">case FRAME_SYN_STREAM:
                err = s.processSynStream(frame)
                select </span>{
                <span class="cov8" title="1">case ns, ok := &lt;-s.new_stream:
                        // registering a new stream for this session
                        if ok </span><span class="cov8" title="1">{
                                s.streams[ns.id] = ns
                        }</span> <span class="cov0" title="0">else {
                                return
                        }</span>
                }
                <span class="cov8" title="1">controlflag := 0
                // for non-FIN frames wait for data frames
                if !frame.isFIN() </span><span class="cov8" title="1">{
                        for controlflag == 0 </span><span class="cov8" title="1">{
                                deadline := time.After(3 * time.Second)
                                select </span>{
                                <span class="cov8" title="1">case f := &lt;-s.in:
                                        // received a frame
                                        switch fr := f.(type) </span>{
                                        <span class="cov8" title="1">case dataFrame:
                                                //process data frames
                                                err = s.processDataFrame(fr)
                                                if fr.isFIN() </span><span class="cov8" title="1">{
                                                        controlflag = 1
                                                }</span>
                                                <span class="cov8" title="1">break</span>
                                        <span class="cov0" title="0">case controlFrame:
                                                err = s.processControlFrame(fr)</span>

                                        }
                                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        <span class="cov8" title="1">break</span>
                                <span class="cov0" title="0">case &lt;-deadline:
                                        //unsuccessfully waited for FIN
                                        debug.Println("Waited long enough but no data frames recieved")
                                        controlflag = 2
                                        break</span>
                                }
                        }
                }
                <span class="cov8" title="1">return</span>
        <span class="cov8" title="1">case FRAME_SYN_REPLY:
                return s.processSynReply(frame)</span>
        <span class="cov0" title="0">case FRAME_SETTINGS:
                return s.processSettings(frame)</span>
        <span class="cov0" title="0">case FRAME_RST_STREAM:
                // just to avoid locking issues, send it in a goroutine
                go s.processRstStream(frame)</span>
        <span class="cov0" title="0">case FRAME_PING:
                return s.processPing(frame)</span>
        <span class="cov8" title="1">case FRAME_WINDOW_UPDATE:
                s.processWindowUpdate(frame)</span>
        <span class="cov0" title="0">case FRAME_GOAWAY:
                panic("FIXME GOAWAY")</span>
        <span class="cov0" title="0">case FRAME_HEADERS:
                panic("FIXME HEADERS")</span>
        }

        <span class="cov8" title="1">return</span>
}

func (s *Session) processDataFrame(frame dataFrame) (err error) <span class="cov8" title="1">{
        stream, found := s.streams[frame.stream]
        if !found </span><span class="cov0" title="0">{
                // no error because this could happen if a stream is closed with outstanding data
                debug.Printf("WARN: stream %d not found", frame.stream)
                return
        }</span>
        // send it to the stream for processing. this BETTER NOT BLOCK!
        <span class="cov8" title="1">deadline := time.After(300 * time.Millisecond)
        select </span>{
        <span class="cov8" title="1">case stream.data &lt;- frame:</span>
                // send this data frame to the corresponding stream
        <span class="cov0" title="0">case &lt;-deadline:
                // maybe it closed just before we tried to send it
                debug.Printf("Stream #%d: session timed out while sending northbound data", stream.id)</span>
        }

        <span class="cov8" title="1">return</span>
}

func (s *Session) processSynStream(frame controlFrame) (err error) <span class="cov8" title="1">{
        _, err = s.newServerStream(frame)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf(fmt.Sprintf("cannot create syn stream frame: %s", err))
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s *Session) processSynReply(frame controlFrame) (err error) <span class="cov8" title="1">{

        debug.Println("Processing SYN_REPLY received")
        id := frame.streamID()
        if id == 0 </span><span class="cov0" title="0">{
                err = errors.New("Invalid stream ID 0 received")
                return
        }</span>

        <span class="cov8" title="1">stream, ok := s.streams[id]
        if !ok </span><span class="cov0" title="0">{
                err = errors.New(fmt.Sprintf("Stream with ID %d not found", id))
                log.Printf("ERROR: %s", err)
                return
        }</span>

        // send this control frame to the corresponding stream
        <span class="cov8" title="1">stream.control &lt;- frame
        return</span>
}

// Read details for SESSIONS frame
func (s *Session) processSettings(frame controlFrame) (err error) <span class="cov0" title="0">{
        s.settings = new(settings)
        data := bytes.NewBuffer(frame.data)
        err = binary.Read(data, binary.BigEndian, &amp;s.settings.count)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">s.settings.svp = make([]settingsValuePairs, s.settings.count)
        for i := uint32(0); i &lt; s.settings.count; i++ </span><span class="cov0" title="0">{
                err = binary.Read(data, binary.BigEndian, &amp;s.settings.svp[i].flags)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">err = binary.Read(data, binary.BigEndian, &amp;s.settings.svp[i].id)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">err = binary.Read(data, binary.BigEndian, &amp;s.settings.svp[i].value)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov0" title="0">return</span>
}

func (s *Session) processRstStream(frame controlFrame) <span class="cov0" title="0">{

        debug.Println("Processing RST_STREAM received")
        id := frame.streamID()
        if id == 0 </span><span class="cov0" title="0">{
                log.Printf("Session: invalid stream ID 0 received")
                return
        }</span>

        <span class="cov0" title="0">stream, ok := s.streams[id]
        if !ok || (ok &amp;&amp; stream.closed) </span><span class="cov0" title="0">{
                debug.Printf("Window update for unknown stream #%d ignored", id)
                debug.Println("known streams are", s.streams)
                return
        }</span>

        // send this control frame to the corresponding stream
        <span class="cov0" title="0">stream.control &lt;- frame</span>
}

// Read details for SESSIONS frame
func (s *Session) processPing(frame controlFrame) (err error) <span class="cov0" title="0">{
        s.settings = new(settings)
        var id uint32
        data := bytes.NewBuffer(frame.data[0:4])
        binary.Read(data, binary.BigEndian, &amp;id)
        debug.Printf("PING #%d", id)

        // check that it's initiated by this end or the other
        if (s.nextPing &amp; 0x00000001) == (uint32(id) &amp; 0x00000001) </span><span class="cov0" title="0">{
                // the ping received matches our partity, do not reply!
                select </span>{
                <span class="cov0" title="0">case s.pinger &lt;- id:</span>
                        // Pingback received successfully
                <span class="cov0" title="0">default:
                        // noone was listening
                        debug.Println("Pingback discarded (received too late)")</span>
                }
                <span class="cov0" title="0">return</span>
        }

        // send it right back!
        <span class="cov0" title="0">s.out &lt;- frame

        return</span>
}

func no_panics() <span class="cov8" title="1">{
        if v := recover(); v != nil </span><span class="cov8" title="1">{
                debug.Println("Got a panic:", v)
        }</span>
}

// Ping issues a SPDY PING frame and returns true if it the other side returned
// the PING frame within the duration, else it returns false. NOTE only one
// outstanting ping works in the current implementation.
func (s *Session) Ping(d time.Duration) (pinged bool) <span class="cov0" title="0">{

        // increase the next ping id
        id := atomic.AddUint32((*uint32)(&amp;s.nextPing), 2) - 2

        data := new(bytes.Buffer)
        binary.Write(data, binary.BigEndian, id)

        ping := controlFrame{kind: FRAME_PING, flags: 0, data: data.Bytes()}

        defer no_panics()

        s.out &lt;- ping

        pinged = false

        select </span>{
        <span class="cov0" title="0">case pid, ok := &lt;-s.pinger:
                if ok </span><span class="cov0" title="0">{ // make sure we get the same id we sent back
                        if pid == id </span><span class="cov0" title="0">{
                                pinged = true
                        }</span>
                }
        <span class="cov0" title="0">case &lt;-time.After(d):
                debug.Printf("Pingback timed out")</span>
                // timeout
        }

        <span class="cov0" title="0">return pinged</span>
}

func (s *Session) processWindowUpdate(frame controlFrame) <span class="cov8" title="1">{

        id := frame.streamID()
        if id == 0 </span><span class="cov0" title="0">{
                panic("no support for session flow control yet")
        }</span>

        <span class="cov8" title="1">stream, ok := s.streams[id]
        if !ok </span><span class="cov8" title="1">{
                debug.Printf("Window update for unknown stream #%d ignored", id)
                return
        }</span>
        <span class="cov8" title="1">if stream.closed </span><span class="cov0" title="0">{
                debug.Printf("Window update for closed stream #%d ignored", id)
                debug.Println("known streams are", s.streams)
                return
        }</span>

        // just to avoid locking issues, send it in a goroutine, and put a deadline
        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                deadline := time.After(1200 * time.Millisecond)
                select </span>{
                <span class="cov8" title="1">case stream.control &lt;- frame:</span>
                        // send this control frame to the corresponding stream
                <span class="cov0" title="0">case &lt;-deadline:
                        // maybe it closed just before we tried to send it
                        debug.Printf("Stream #%d: session timed out while sending %s north", stream.id, frame)</span>
                }
        }()
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2013, Amahi.  All rights reserved.
// Use of this source code is governed by the
// license that can be found in the LICENSE file.

// Stream related functions

package spdy

import (
        "bytes"
        "encoding/binary"
        "errors"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "runtime"
        "strconv"
        "strings"
        "time"
)

const INITIAL_FLOW_CONTOL_WINDOW int32 = 64 * 1024
const NORTHBOUND_SLOTS = 5

// NewClientStream starts a new Stream (in the given Session), to be used as a client
func (s *Session) NewClientStream() *Stream <span class="cov8" title="1">{
        str := &amp;Stream{
                id:                s.nextStreamID(),
                session:           s,
                priority:          4, // FIXME need to implement priorities
                associated_stream: 0, // FIXME for pushes we need to implement it
                control:           make(chan controlFrame),
                data:              make(chan dataFrame),
                response:          make(chan bool),
                eos:               make(chan bool),
                stop_server:       make(chan bool),
                flow_req:          make(chan int32, 1),
                flow_add:          make(chan int32, 1),
                upstream_buffer:   make(chan upstream_data, NORTHBOUND_SLOTS),
        }

        go str.serve()

        go str.northboundBufferSender()

        go str.flowManager(INITIAL_FLOW_CONTOL_WINDOW, str.flow_add, str.flow_req)

        // add the stream to the session

        deadline := time.After(1500 * time.Millisecond)
        select </span>{
        <span class="cov8" title="1">case s.new_stream &lt;- str:
                // done
                return str</span>
        <span class="cov0" title="0">case &lt;-deadline:
                // somehow it was locked
                debug.Printf("Stream #%d: cannot be created. Stream is hung. Resetting it.", str.id)
                s.Close()
                return nil</span>
        }
}

func (s *Session) newServerStream(frame controlFrame) (str *Stream, err error) <span class="cov8" title="1">{

        str = &amp;Stream{
                id:                frame.streamID(),
                session:           s,
                priority:          4, // FIXME need to implement priorities
                associated_stream: 0, // FIXME for pushes we need to implement it
                control:           make(chan controlFrame),
                data:              make(chan dataFrame),
                response:          make(chan bool),
                eos:               make(chan bool),
                stop_server:       make(chan bool),
                flow_req:          make(chan int32, 1),
                flow_add:          make(chan int32, 1),
        }

        go str.serve()

        go str.flowManager(INITIAL_FLOW_CONTOL_WINDOW, str.flow_add, str.flow_req)

        // send the SYN_STREAM control frame to get it started
        str.control &lt;- frame
        return
}</span>

// String returns the Stream ID of the Stream
func (s *Stream) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%d", s.id)
}</span>

// prepare the header of the request in SPDY format
func (s *Stream) prepareRequestHeader(request *http.Request) (err error) <span class="cov8" title="1">{
        url := request.URL
        if url != nil &amp;&amp; url.Path == "" </span><span class="cov0" title="0">{
                url.Path = "/"
        }</span>
        <span class="cov8" title="1">if url == nil || url.Scheme == "" || url.Host == "" || url.Path == "" </span><span class="cov0" title="0">{
                err = errors.New(fmt.Sprintf("ERROR: Incomplete path provided: scheme=%s host=%s path=%s", url.Scheme, url.Host, url.Path))
                return
        }</span>
        <span class="cov8" title="1">path := url.Path
        if url.RawQuery != "" </span><span class="cov0" title="0">{
                path += "?" + url.RawQuery
        }</span>
        <span class="cov8" title="1">if url.Fragment != "" </span><span class="cov0" title="0">{
                path += "#" + url.Fragment
        }</span>

        // normalize host:port
        <span class="cov8" title="1">if !strings.Contains(url.Host, ":") </span><span class="cov0" title="0">{
                switch url.Scheme </span>{
                <span class="cov0" title="0">case "http":
                        url.Host += ":80"</span>
                <span class="cov0" title="0">case "https":
                        url.Host += ":443"</span>
                }
        }

        // set all SPDY headers
        <span class="cov8" title="1">request.Header.Set(HEADER_METHOD, request.Method)
        request.Header.Set(HEADER_PATH, path)
        request.Header.Set(HEADER_VERSION, request.Proto)
        request.Header.Set(HEADER_HOST, url.Host)
        request.Header.Set(HEADER_SCHEME, url.Scheme)

        request.Header.Del("Connection")
        request.Header.Del("Host")
        request.Header.Del("Keep-Alive")
        request.Header.Del("Proxy-Connection")
        request.Header.Del("Transfer-Encoding")

        return nil</span>
}

func (s *Stream) prepareRequestBody(request *http.Request) (body []*dataFrame, err error) <span class="cov8" title="1">{

        body = make([]*dataFrame, 0, 1)
        if request.Body == nil </span><span class="cov0" title="0">{
                return body, nil
        }</span>

        <span class="cov8" title="1">buf := make([]byte, 32*1024)
        n, err := request.Body.Read(buf)
        if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">total := n
        for n &gt; 0 </span><span class="cov8" title="1">{
                data := new(dataFrame)
                data.data = make([]byte, n)
                copy(data.data, buf[:n])
                body = append(body, data)
                n, err = request.Body.Read(buf)
                if err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">total += n</span>
        }

        // Half-close the stream.
        <span class="cov8" title="1">if len(body) != 0 </span><span class="cov8" title="1">{
                request.Header.Set("Content-Length", fmt.Sprint(total))
                body[len(body)-1].flags = FLAG_FIN
        }</span>
        <span class="cov8" title="1">request.Body.Close()

        err = nil // in case it was EOF, which is not an error

        return</span>
}

func (s *Stream) handleRequest(request *http.Request) (err error) <span class="cov8" title="1">{
        err = s.prepareRequestHeader(request)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">flags := FLAG_NONE
        if request.Body == nil </span><span class="cov0" title="0">{
                flags = FLAG_FIN
        }</span>

        <span class="cov8" title="1">body, err := s.prepareRequestBody(request)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if len(body) == 0 </span><span class="cov8" title="1">{
                flags = FLAG_FIN
        }</span>

        // send the SYN frame to start the stream
        <span class="cov8" title="1">f := frameSynStream{session: s.session, stream: s.id, header: request.Header, flags: flags}
        debug.Println("Sending SYN_STREAM:", f)
        s.session.out &lt;- f

        // send the DATA frames for the body
        for _, frame := range body </span><span class="cov8" title="1">{
                frame.stream = s.id
                s.session.out &lt;- frame
        }</span>

        // need to return now but the data pieces will be picked up
        // and the eos channel will be notified when done

        <span class="cov8" title="1">return nil</span>
}

// Request makes an http request down the client that gets a client Stream
// started and returning the request in the ResponseWriter
func (s *Stream) Request(request *http.Request, writer http.ResponseWriter) (err error) <span class="cov8" title="1">{

        s.response_writer = writer

        err = s.handleRequest(request)
        if err != nil </span><span class="cov0" title="0">{
                debug.Println("ERROR in stream.serve/http.Request:", err)
                return
        }</span>

        <span class="cov8" title="1">debug.Printf("Waiting for #%d to end", s.id)

        // the response is finished sending
        &lt;-s.eos

        s.finish_stream()

        return</span>
}

func (s *Stream) finish_stream() <span class="cov8" title="1">{

        defer no_panics()
        deadline := time.After(500 * time.Millisecond)

        select </span>{
        <span class="cov8" title="1">case s.stop_server &lt;- true:</span>
                // done
        <span class="cov0" title="0">case &lt;-deadline:
                // well, somehow it was locked
                debug.Printf("Stream #%d: Request() timed out while stopping", s.id)</span>
        }

}

// Takes a SYN_STREAM control frame and kicks off a stream, calling the handler
func (s *Stream) initiate_stream(frame controlFrame) (err error) <span class="cov8" title="1">{
        debug.Println("Stream server got SYN_STREAM")

        s.id = frame.streamID()

        data := bytes.NewBuffer(frame.data[4:])

        // add the stream to the map of streams in the session
        // note that above the message sending the ID is zero initially!
        s.session.new_stream &lt;- s

        var associated_id uint32
        err = binary.Read(data, binary.BigEndian, &amp;associated_id)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.associated_stream = streamID(associated_id &amp; 0x7fffffff)

        var b uint8
        err = binary.Read(data, binary.BigEndian, &amp;b)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">s.priority = (b &amp; (0x7 &lt;&lt; 5)) &gt;&gt; 5

        // skip over the "slot" of unused space
        _, err = io.ReadFull(data, make([]byte, 1))
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">headers := make(http.Header)
        // debug.Println("header data:", data.Bytes())
        headers, err = s.session.headerReader.decode(data.Bytes())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">headers.Del("Connection")
        headers.Del("Host")
        headers.Del("Keep-Alive")
        headers.Del("Proxy-Connection")
        headers.Del("Transfer-Encoding")

        s.headers = headers

        // build the frame just for printing it
        ss := frameSynStream{
                session:           s.session,
                stream:            s.id,
                priority:          s.priority,
                associated_stream: s.associated_stream,
                header:            headers,
                flags:             frame.flags}

        debug.Println("Processing SYN_STREAM", ss)
        if frame.isFIN() </span><span class="cov8" title="1">{
                // call the handler

                req := &amp;http.Request{
                        Method:     headers.Get(HEADER_METHOD),
                        Proto:      headers.Get(HEADER_VERSION),
                        Header:     headers,
                        RemoteAddr: s.session.conn.RemoteAddr().String(),
                }
                req.URL, _ = url.ParseRequestURI(headers.Get(HEADER_PATH))

                // Clear the headers in the session now that the request has them
                s.headers = make(http.Header)

                go s.requestHandler(req)

        }</span> <span class="cov8" title="1">else {
                var data []byte

                endflag := 0
                for endflag == 0 </span><span class="cov8" title="1">{
                        deadline := time.After(3 * time.Second)
                        select </span>{
                        <span class="cov8" title="1">case df, ok := &lt;-s.data:
                                //collecting data
                                if !ok </span><span class="cov0" title="0">{
                                        debug.Println("Error collecting data frames", ok)
                                        return
                                }</span>
                                <span class="cov8" title="1">data = append(data, df.data...)
                                if df.isFIN() </span><span class="cov8" title="1">{
                                        endflag = 1
                                }</span>
                                <span class="cov8" title="1">break</span>

                        <span class="cov0" title="0">case &lt;-deadline:
                                //unsuccessfully waited for FIN
                                // no activity in a while. Assume that body is completely recieved. Bail
                                //panic("Waited long enough but no data frames recieved")
                                debug.Println("Waited long enough but no data frames recieved")
                                endflag = 2
                                break</span>
                        }
                }
                <span class="cov8" title="1">if endflag == 1 </span><span class="cov8" title="1">{
                        //http request if data frames collected sucessfully
                        // call the handler
                        contLen, _ := strconv.Atoi(headers.Get(HEADER_CONTENT_LENGTH))
                        req := &amp;http.Request{
                                Method:        headers.Get(HEADER_METHOD),
                                Proto:         headers.Get(HEADER_VERSION),
                                Header:        headers,
                                RemoteAddr:    s.session.conn.RemoteAddr().String(),
                                ContentLength: int64(contLen),
                                Body:          &amp;readCloser{bytes.NewReader(data)},
                        }
                        req.URL, _ = url.ParseRequestURI(headers.Get(HEADER_PATH))

                        // Clear the headers in the session now that the request has them
                        s.headers = make(http.Header)

                        go s.requestHandler(req)
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}
func (s *Stream) requestHandler(req *http.Request) <span class="cov8" title="1">{
        // call the handler - this writes the SYN_REPLY and all data frames
        s.session.server.Handler.ServeHTTP(s, req)

        debug.Printf("Sending final DATA with FIN the handler for #%d", s.id)

        // send an empty data frame with FIN set to end the deal
        frame := dataFrame{stream: s.id, flags: FLAG_FIN}
        s.session.out &lt;- frame

        // close shop for this stream's end
        if !s.closed </span><span class="cov8" title="1">{
                s.stop_server &lt;- true
        }</span>
}

func (s *Stream) serve() <span class="cov8" title="1">{

        debug.Printf("Stream #%d main loop", s.id)

        err := s.stream_loop()
        if err != nil </span><span class="cov0" title="0">{
                debug.Println("ERROR in stream loop:", err)
        }</span>

        <span class="cov8" title="1">s.closed = true

        deadline := time.After(1500 * time.Millisecond)
        select </span>{
        <span class="cov8" title="1">case s.session.end_stream &lt;- s:</span>
                // done, all good!
        <span class="cov0" title="0">case &lt;-deadline:
                // somehow it was locked
                debug.Printf("Stream #%d: timed out and cannot be removed from the session", s.id)</span>
        }

        <span class="cov8" title="1">if s.upstream_buffer != nil </span><span class="cov8" title="1">{
                // this is not a server stream
                close(s.upstream_buffer)
        }</span>
        <span class="cov8" title="1">close(s.flow_add)
        close(s.flow_req)
        debug.Printf("Stream #%d main loop done", s.id)</span>
}

// stream server loop
func (s *Stream) stream_loop() (err error) <span class="cov8" title="1">{

        for </span><span class="cov8" title="1">{
                deadline := time.After(10 * time.Second)
                select </span>{
                <span class="cov8" title="1">case cf, ok := &lt;-s.control:
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">switch cf.kind </span>{
                        <span class="cov8" title="1">case FRAME_SYN_STREAM:
                                err = s.initiate_stream(cf)
                                debug.Println("Goroutines:", runtime.NumGoroutine())</span>
                        <span class="cov8" title="1">case FRAME_SYN_REPLY:
                                err = s.handleSynReply(cf)</span>
                        <span class="cov0" title="0">case FRAME_RST_STREAM:
                                err = s.handleRstStream(cf)
                                return</span>
                        <span class="cov8" title="1">case FRAME_WINDOW_UPDATE:
                                s.handleWindowUpdate(cf)</span>
                        <span class="cov0" title="0">default:
                                panic("TODO: unhandled type of frame received in stream.serve()")</span>
                        }
                <span class="cov8" title="1">case df, ok := &lt;-s.data:
                        if !ok </span><span class="cov0" title="0">{
                                return
                        }</span>
                        <span class="cov8" title="1">err = s.handleDataFrame(df)</span>
                <span class="cov0" title="0">case &lt;-deadline:
                        // no activity in a while. bail
                        return</span>
                <span class="cov8" title="1">case _, _ = &lt;-s.stop_server:
                        return</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        // finish the loop with any error, data or control
                        return
                }</span>
        }
}

// Header makes streams compatible with the net/http handlers interface
func (s *Stream) Header() http.Header <span class="cov8" title="1">{ return s.headers }</span>

// Write makes streams compatible with the net/http handlers interface
func (s *Stream) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        if s.closed </span><span class="cov0" title="0">{
                err = errors.New(fmt.Sprintf("Stream #%d: write on closed stream!", s.id))
                return
        }</span>
        <span class="cov8" title="1">if !s.wroteHeader </span><span class="cov8" title="1">{
                s.WriteHeader(http.StatusOK)
        }</span>
        <span class="cov8" title="1">lp := int32(len(p))
        if lp == 0 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">flow := int32(0)
        for lp &gt; flow </span><span class="cov8" title="1">{
                // if there is data to send and it's larger than the flow control window
                // we need to stall until we have enough to go
                window, ok := &lt;-s.flow_req
                debug.Printf("Stream #%d: got %d bytes of flow", s.id, window)
                if !ok || s.closed </span><span class="cov0" title="0">{
                        debug.Printf("Stream #%d: flow closed!", s.id)
                        return 0, errors.New(fmt.Sprintf("Stream #%d closed while writing"))
                }</span>
                <span class="cov8" title="1">flow += window</span>
        }
        // this is just in case we end up trying to write while on network turbulence
        <span class="cov8" title="1">defer no_panics()
        for len(p) &gt; 0 </span><span class="cov8" title="1">{
                frame := dataFrame{stream: s.id}
                if len(p) &lt; MAX_DATA_PAYLOAD </span><span class="cov8" title="1">{
                        frame.data = make([]byte, len(p))
                }</span> <span class="cov0" title="0">else {
                        frame.data = make([]byte, MAX_DATA_PAYLOAD)
                }</span>
                <span class="cov8" title="1">copy(frame.data, p)
                p = p[len(frame.data):]
                s.session.out &lt;- frame
                n += len(frame.data)</span>
        }

        // put the rest back in the flow control window
        <span class="cov8" title="1">s.flow_add &lt;- flow - int32(n)
        debug.Printf("Stream #%d: FCW updated -%d: %d -&gt; %d", s.id, int32(n), flow, flow-int32(n))

        return</span>
}

// WriteHeader makes streams compatible with the net/http handlers interface
func (s *Stream) WriteHeader(code int) <span class="cov8" title="1">{
        if s.wroteHeader </span><span class="cov0" title="0">{
                log.Println("ERROR: Multiple calls to ResponseWriter.WriteHeader.")
                return
        }</span>

        // send basic SPDY fields
        <span class="cov8" title="1">s.headers.Set(HEADER_STATUS, strconv.Itoa(code)+" "+http.StatusText(code))
        s.headers.Set(HEADER_VERSION, "HTTP/1.1")

        if s.headers.Get("Content-Type") == "" </span><span class="cov0" title="0">{
                s.headers.Set("Content-Type", "text/html; charset=utf-8")
        }</span>
        <span class="cov8" title="1">if s.headers.Get("Date") == "" </span><span class="cov8" title="1">{
                s.headers.Set("Date", time.Now().UTC().Format(http.TimeFormat))
        }</span>
        // Write the frame
        <span class="cov8" title="1">sr := frameSynReply{session: s.session, stream: s.id, headers: s.headers}
        debug.Println("Sending SYN_REPLY", sr)
        s.session.out &lt;- sr
        s.wroteHeader = true</span>
}

// takes a SYN_REPLY control frame
func (s *Stream) handleSynReply(frame controlFrame) (err error) <span class="cov8" title="1">{

        debug.Println("Stream server got SYN_REPLY")

        s.headers, err = s.session.headerReader.decode(frame.data[4:])
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">h := s.response_writer.Header()
        for name, values := range s.headers </span><span class="cov8" title="1">{
                if name[0] == ':' </span><span class="cov8" title="1">{ // skip SPDY headers
                        continue</span>
                }
                <span class="cov8" title="1">for _, value := range values </span><span class="cov8" title="1">{
                        debug.Printf("Header: %s -&gt; %s\n", name, value)
                        h.Set(name, value)
                }</span>
        }
        <span class="cov8" title="1">status := s.headers.Get(HEADER_STATUS)
        code, err := strconv.Atoi(status[0:3])
        if err != nil </span><span class="cov0" title="0">{
                log.Println("ERROR: handleSynReply: got an unparseable status:", status)
        }</span>
        <span class="cov8" title="1">debug.Printf("Header status code: %d\n", code)

        // *could* this conceivably block or time out?
        // we would need to write it through a similar the upstream data sender
        // but remember to NOT update the delta window with this data
        s.response_writer.WriteHeader(code)

        if frame.isFIN() </span><span class="cov0" title="0">{
                debug.Println("Stream FIN found in SYN_REPLY frame")
                s.eos &lt;- true
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// send stream cancellation
func (s *Stream) sendRstStream() <span class="cov0" title="0">{
        data := new(bytes.Buffer)
        binary.Write(data, binary.BigEndian, s.id)
        // FIXME this needs some cleaning
        var code uint32 = 5 // CANCEL
        binary.Write(data, binary.BigEndian, code)

        rst_stream := controlFrame{kind: FRAME_RST_STREAM, data: data.Bytes()}
        s.session.out &lt;- rst_stream
}</span>

// takes a DATA frame and adds it to the running body of the stream
func (s *Stream) handleDataFrame(frame dataFrame) (err error) <span class="cov8" title="1">{

        debug.Println("Stream server got DATA")

        if len(s.upstream_buffer) &gt;= NORTHBOUND_SLOTS </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("upstream buffering hit the limit of %d buffers", NORTHBOUND_SLOTS)
                log.Println(msg)
                err = errors.New(msg)
                return
        }</span>

        <span class="cov8" title="1">debug.Printf("Stream #%d adding +%d to upstream data queue. FIN? %v", s.id, len(frame.data), frame.isFIN())
        s.upstream_buffer &lt;- upstream_data{frame.data, frame.isFIN()}
        debug.Printf("Stream #%d data queue size: %d", s.id, len(s.upstream_buffer))

        return</span>
}

func (s *Stream) northboundBufferSender() <span class="cov8" title="1">{
        defer no_panics()
        for f := range s.upstream_buffer </span><span class="cov8" title="1">{
                var err error
                data := f.data
                size := len(data)
                for l := size; l &gt; 0; l = len(data) </span><span class="cov8" title="1">{
                        debug.Printf("Stream #%d trying to write %d upstream bytes", s.id, l)
                        written, err := s.response_writer.Write(data)
                        if err == nil &amp;&amp; written == l </span><span class="cov8" title="1">{
                                // sunny day scenario!
                                break</span>
                        }
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                if !isBrokenPipe(err) </span><span class="cov0" title="0">{
                                        log.Printf("ERROR found writing northbound stream #%d:, %#v", s.id, err)
                                }</span>
                                <span class="cov0" title="0">s.sendRstStream()
                                s.eos &lt;- true
                                return</span>
                        }
                        <span class="cov0" title="0">if written != l </span><span class="cov0" title="0">{
                                debug.Printf("Stream #%d: northboundBufferSender: only %d of %d were written", s.id, written, l)
                                time.Sleep(2 * time.Second)
                        }</span>
                        <span class="cov0" title="0">data = data[written:]</span>
                }
                // all good with this write
                <span class="cov8" title="1">if size &gt; 0 </span><span class="cov8" title="1">{
                        debug.Printf("Stream #%d: %d bytes successfully written upstream", s.id, size)
                        wupdate := windowUpdateFor(s.id, size)
                        s.session.out &lt;- wupdate
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; f.final </span><span class="cov8" title="1">{
                        debug.Printf("Stream #%d: last upstream data done!", s.id)
                        s.eos &lt;- true
                        break</span>
                }
        }
        <span class="cov8" title="1">debug.Printf("Stream #%d: northboundBufferSender done!", s.id)</span>
}

// Close does nothing and is here only to allow the data of a request to become
// the body of a response
func (r *readCloser) Close() error <span class="cov0" title="0">{ return nil }</span>

func (s *Stream) handleRstStream(frame controlFrame) (err error) <span class="cov0" title="0">{

        debug.Println("Stream server got RST_STREAM")

        id := frame.streamID()

        data := bytes.NewBuffer(frame.data[4:])
        var status uint32
        err = binary.Read(data, binary.BigEndian, &amp;status)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">debug.Printf("Stream #%d cancelled with status code %d", id, status)

        return nil</span>
}

// handle WINDOW_UPDATE from the other side
func (s *Stream) handleWindowUpdate(frame controlFrame) <span class="cov8" title="1">{

        debug.Println("Stream server got WINDOW_UPDATE")

        if s.closed </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">data := bytes.NewBuffer(frame.data[4:8])
        var size uint32
        binary.Read(data, binary.BigEndian, &amp;size)
        size &amp;= 0x7fffffff

        // add the window size update from the flow control window
        s.flow_add &lt;- int32(size)
        debug.Printf("Stream #%d window size +%d", s.id, int32(size))</span>
}

// flowManager is a coroutine to manage the flow control window in an atomic manner
// so that there are no race conditions and it's easier to expand later w/ SETTINGS
func (s *Stream) flowManager(initial int32, in &lt;-chan int32, out chan&lt;- int32) <span class="cov8" title="1">{
        debug.Printf("Stream #%d flow manager started", s.id)
        // no panics; it could be that we get clipped trying to send when out is closed
        defer no_panics()
        sfcw := initial
        for </span><span class="cov8" title="1">{
                if sfcw &gt; 0 </span><span class="cov8" title="1">{
                        debug.Printf("Stream #%d window size %d", s.id, sfcw)
                        select </span>{
                        <span class="cov8" title="1">case v, ok := &lt;-in:
                                if s.closed || !ok </span><span class="cov8" title="1">{
                                        return
                                }</span>
                                <span class="cov0" title="0">sfcw += v</span>
                        <span class="cov8" title="1">case out &lt;- sfcw:
                                sfcw = 0</span>
                        }
                } <span class="cov8" title="1">else {
                        debug.Printf("Stream #%d window size %d", s.id, sfcw)
                        v, ok := &lt;-in
                        if s.closed || !ok </span><span class="cov8" title="1">{
                                return
                        }</span>
                        <span class="cov8" title="1">sfcw += v</span>
                }
                <span class="cov8" title="1">if s.closed </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        <span class="cov0" title="0">debug.Printf("Stream #%d flow manager done", s.id)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible = document.getElementById('file0');
		files.addEventListener('change', onChange, false);
		function onChange() {
			visible.style.display = 'none';
			visible = document.getElementById(files.value);
			visible.style.display = 'block';
			window.scrollTo(0, 0);
		}
	})();
	</script>
</html>
